## 결과

그동안 공부했던 내용들 살짝 점검

## JVM
#### Garabage ?
Reachability 개념, Root set 으로부터 unreachable 한 객체가 garbage 로 간주됨
reachability 에 따라 약한 것도 GC 대상이 되기도함.
- GC가 발생하는 부분은 힙영역
- GC는 메모리 할당, 사용중 메모리 인식, 사용하지 않는 메모리 인식

#### GC 알고리즘
(1번참고) 여러 알고리즘이 있지만 현재는 young, old 영역으로 구분하는 generational algorithm
- GC의 동작 과정
- GC 2가지 종류

#### GC의 방식
5가지가 있는데 9부터는 G1GC가 디폴트

## Effective Java
#### 객체생성과 파괴
- 정적팩터리 메서드
- 장점 : 이름, 인스턴스 통제(싱글톤 등), 하위타입 객체로 반환할 수 있다, 매개변수에 따라 다른 클래스의 객체를 반환할 수 있음. 정적 팩토리 메서드를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않아도됨,
- 단점 : 상속을 하기위해서는 public, protected 생성자가 필요함, 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없음, 근데 컴포지션으로 해결가능, 개발자가 찾기 어려움

#### 클래스와 인터페이스
- protect vs package-private : protect는 package-private 범위 모두 포함하고 상속받은 하위 클래스에서도 접근가능함
- 하위 클래스는 상위 클래스보다 좁게 설정하지 못함 : 리스코프 치환 원칙 때문에, 따라서 한번 공개되면 계속 공개돼..
- public 클래스의 인스턴스 필드를 public 으로 하면, 불변을 보장할 수 없게되고 스레드 안전하지 못함, 이거는 final 붙이고 불변객체를 참조하더라도 내부 구현을 바꾸지 못하니까 , 부수작업 못하니까.. 불변식은 보장하더라도
- package-private 클래스나 private 중첩 클래스는 데이터 필드를 노출해도 상관없다
- 불변 만들기 : 변경자 제공하지 않고, 클래스 확장하지 못하게하고(final이나 생성자 private), 모든 필드를 final로 , 모든 필드를 private으로 , 자신 외에 내부의 가변 컴포넌트에 접근 할 수 없도록 방어적 복사를 수행해야함 , 좋은점 : 단순하고 스레드 안전해
- 상속의 문제점 : 하위클래스 코드 변경 한줄없이 상위클래스 의 변화로 문제가 생길 수 있음
- 정적 내부 클래스는 바깐 클래스의 private 멤버에 접근할 수 있음

#### 람다와 스트림
- 익명 클래스와 람다의 차이 : 가장 큰 특징은 간결함의 차이, 생성방식에는 람다는 하나의 메서드 정의한 인터페이스~
- forEach (종단)연산은 결과를 보고할 때만
- 병렬스트림은 크기가 정확하고 손쉽게 나눌수 있는 소스에 대해서만, 즉 참조 지역성이 뛰어난, 그리고 반드시 성능 테스트할것

#### 메서드
- 오류가 발생했을 때 발생 지점을 찾기 어려워짐, 그래서 유효성 검사가 팰요해
- 방어적복사
- 가변인수 인수가 1개이사잉어야할때, 95%가 인수를 3개 이하로 사용할때, 호출될 때마다배열을 새로 하나 할당하고 초기화 하기때문에 비용이 많이들어

#### 예외
- 복구할 수 있으면 체크드 익셉션 , 프로그래밍 오류에는 런타임
- 실패 원자성 : 메서드가 실패하더라도 객체는 메서드 호출 전 상태를 유지해야 한다.
  - 방법 : 1.불변 2.유효성 검사 3.복사본에서 작업 수행 4.롤백

#### 동시성
- 아이템 78 
  - A가 B가 동시에 읽어 A가 값을 바꿈 그다음 B가 바꾸려고할때 atomic 이라면 실패하고 재시도해
  - 이러한 atomic 변수라도 동시성 문제가 발생할 수 있어 그게 언제냐면 A가 쓰고나서 다른쓰레드에서도 그 A가 바꾼값이 
  - 반영되어있는가는 보장할 수 없어 , 따라서 스레드사이에 안정적인 통신에 synchronized 는 필요해
  
  
## 토비의 스프링

ISP DIP 에 대해서..
빈 팩토리, 어플리케이션 컨텍스트
동일성, 동등성

#### 싱글톤과 스테틱의 차이
- 싱글톤패턴의 문제점 107p
- 프로토타입 스코프, 요청 스코프, 세션스코프
- 메소드 주입의 3가지 방법 why?

#### 언체크/체크 익셉션
- 로직과 관련된걸 체크 익셉션으로 만들자 : 복구 가능
- 언체크드 익셉션은 예상하지 못했던 예외상황이아니라 부주의에 의한것 // 조건을 잘 하면 피할 수 있다
- 파일을 읽어야 되는데 없어 -> 이건 진짜 예외잖아 이럴땐 체크드 익셉션을 통해 안내를줘서 복구를 해줘야지
 
#### 스프링
- 오브젝트 생성, 동작의 틀을 제공 + 코드를 어떻게 작성해야 하는가 제시 == 프로그레밍 모델
- PM 3가지 
  1. IoC/DI : 생명주기, 의존관계 // 객체지향 설계원칙에 맞춰서
  2. PSA : 특정기술에 종속되지 않고 유연하게
  3. AoP : 부가적인 기능을 독립적으로 모듈화

- 가치 : 단순함, 유연성 , 개발자들에게는 객체지향과 테스트

#### AOP
- 프록시 : 프록시 패턴과 데코레이터 패턴 // 기존 코드에 영향을 주지 않으면서 기능확장 + 접근제어
- 프록시 패턴 : 접근 방식 제어, 늦추거나 원격오브젝트나 접근 권한 등
  - 1.프록시는 인터페이스를 만들고 일일히 구현해서 위임하는 코드를 넣어야 하기 때문 번거롭..  -> 다이나믹 프록시로 해결
  - 2.부가기능 코드가 중복이 돼 -> 팩토리 빈
- 다이나믹 프록시 : 프록시 팩토리를 통해 타깃과 같은 인터페이스를 구현하여 자동으로 만들어줌
- 부가기능은 InvocationHandler 를 구현해서 담자
- 이렇게 만들어진 다이나믹 프록시는 스프링 빈으로 만들 방법이없네.. 클래스의 이름과 프로퍼티로 정의되는데
- 다이나믹 프록시는 내부적으로 다이나믹하게 새로 정의해서 사용하잖아 파라미터로 타깃넘겨서
- 그러니까 미리 빈으로 등록할 수 가없지 , 그래서있는게 팩토리빈
- 팩토리 빈 : 리플렉션의 기본생성자를 통해 빈을 만드는 것 외에 또다른방법
- 이걸 재사용이 가능하여 부가기능 코드 중복 해결
- 서비스 추상화가 적용된 ProxyFactoryBean
- DefaultAdvisortAutoProxyCreator : 자동 프록시 생성 빈 후처리기
- 포인트컷은 : 클래스, 메서드 둘다 가능

## 자료구조

#### Hash

- 얼마나 잘 고르게 분포해서 완전해쉬함수를 만드느냐
- 이렇게 해도 논리적으로 2^32 가 넘어가는 경우의 수를 가진다면 결국에는 충돌이 일어남
- 그리고 2^32 개에 배열을 만드는건 메모리낭비 // bucket Size
- Open Adrressing, Seperate Chaining
- 데이터가 적다면 OA가 성능이 좋음, 연속돼있기때문에
- tree vs linkedList
- 버킷도 성능에따라 동적으로 확장됨 2^4 부터시작해서 2배씩 2^30까지
- 이때 새롭게 Seperate Chaining 문제가 있기떄문에 개수를 정확하게 알고있다면 사이즈고정
- 3/4이 채워지면 2배 미리늘려놓음 이 load factor 도 지정할 수 있음
- 근데 여기에는 문제가있어 2배씩 늘리다보니 2^a 형태임 즉 하위 a개의 비트만 사용한다
- 이문제를 해결하는게 보조해시함수
- 문자열같은경우는 길이 15까지 1칸 16부터 8칸마다 1칸씩증가 이거 문제가 많아 폐기됨

#### Tree

- 노드를 인덱스로 배열(힙) vs 링크로
- 삭제할 때 기억하기
- AVL Tree, Red-Black Tree